#include "DNSManager.h"
#include <iostream>
#include <sstream>
#include <cstring>
#include <ctime>
#include <algorithm>

DNSManager::DNSManager()
    : initialized_(false), cache_enabled_(true), cache_ttl_(3600) {
    stats_.total_queries = 0;
    stats_.cache_hits = 0;
    stats_.cache_misses = 0;
    stats_.failed_queries = 0;
}

DNSManager::~DNSManager() {
}

bool DNSManager::initialize() {
    if (initialized_) {
        return true;
    }

    // 添加默认的DNS服务器（Google DNS）
    DNSServer google_dns;
    google_dns.ip_address = "8.8.8.8";
    google_dns.priority = 1;
    google_dns.interface = "";
    dns_servers_[google_dns.ip_address] = google_dns;

    // 添加备用DNS服务器
    DNSServer google_dns2;
    google_dns2.ip_address = "8.8.4.4";
    google_dns2.priority = 2;
    google_dns2.interface = "";
    dns_servers_[google_dns2.ip_address] = google_dns2;

    initialized_ = true;
    return true;
}

std::vector<DNSServer> DNSManager::getDNSServers() const {
    std::vector<DNSServer> result;
    for (const auto& pair : dns_servers_) {
        result.push_back(pair.second);
    }
    return result;
}

bool DNSManager::addDNSServer(const DNSServer& server) {
    dns_servers_[server.ip_address] = server;
    std::cout << "[DNSManager] Added DNS server: " << server.ip_address << std::endl;
    return true;
}

bool DNSManager::removeDNSServer(const std::string& ip_address) {
    auto it = dns_servers_.find(ip_address);
    if (it != dns_servers_.end()) {
        dns_servers_.erase(it);
        std::cout << "[DNSManager] Removed DNS server: " << ip_address << std::endl;
        return true;
    }
    return false;
}

bool DNSManager::setDefaultDNSServer(const std::string& ip_address) {
    auto it = dns_servers_.find(ip_address);
    if (it == dns_servers_.end()) {
        return false;
    }

    // 将选中的DNS服务器优先级设为1，其他服务器优先级递增
    for (auto& pair : dns_servers_) {
        if (pair.first == ip_address) {
            pair.second.priority = 1;
        } else {
            pair.second.priority++;
        }
    }

    return true;
}

DNSResolution DNSManager::resolve(const std::string& hostname, DNSQueryType query_type) {
    stats_.total_queries++;

    // 清理过期缓存
    cleanupExpiredCache();

    // 检查缓存
    if (cache_enabled_) {
        DNSCacheEntry* cached = findInCache(hostname);
        if (cached) {
            stats_.cache_hits++;
            DNSResolution result = cached->resolution;
            if (dns_callback_) {
                dns_callback_(hostname, result);
            }
            return result;
        }
    }

    stats_.cache_misses++;

    // 执行DNS查询
    DNSResolution result = performDNSQuery(hostname, query_type);

    // 缓存结果
    if (result.success && cache_enabled_) {
        addToCache(hostname, result);
    } else {
        stats_.failed_queries++;
    }

    if (dns_callback_) {
        dns_callback_(hostname, result);
    }

    return result;
}

DNSResolution DNSManager::reverseLookup(const std::string& ip_address) {
    stats_.total_queries++;

    // 执行反向DNS查询
    DNSResolution result;
    result.hostname = ip_address;
    
    std::ostringstream cmd;
    cmd << "nslookup " << ip_address;

    std::cout << "[DNSManager] Executing: " << cmd.str() << std::endl;
    
    // 模拟执行
    result.success = true;
    result.ip_addresses.push_back("example.com");
    result.dns_server = dns_servers_.empty() ? "" : dns_servers_.begin()->second.ip_address;
    result.ttl = cache_ttl_;

    if (!result.success) {
        stats_.failed_queries++;
    }

    return result;
}

bool DNSManager::clearCache() {
    dns_cache_.clear();
    std::cout << "[DNSManager] DNS cache cleared" << std::endl;
    return true;
}

bool DNSManager::refreshCache() {
    // 清理过期条目
    cleanupExpiredCache();
    return true;
}

std::vector<DNSCacheEntry> DNSManager::getCache() const {
    std::vector<DNSCacheEntry> result;
    for (const auto& pair : dns_cache_) {
        result.push_back(pair.second);
    }
    return result;
}

bool DNSManager::setCacheTTL(int ttl) {
    if (ttl < 0) {
        return false;
    }
    cache_ttl_ = ttl;
    std::cout << "[DNSManager] DNS cache TTL set to " << ttl << " seconds" << std::endl;
    return true;
}

bool DNSManager::setCacheEnabled(bool enabled) {
    cache_enabled_ = enabled;
    std::cout << "[DNSManager] DNS cache " << (enabled ? "enabled" : "disabled") << std::endl;
    return true;
}

bool DNSManager::configureSystemDNS() {
    std::ostringstream resolv_conf;
    resolv_conf << "# Generated by NetDaemon\n";
    resolv_conf << "# Do not edit this file manually\n\n";

    // 添加搜索域
    if (!search_domains_.empty()) {
        resolv_conf << "search";
        for (const auto& domain : search_domains_) {
            resolv_conf << " " << domain;
        }
        resolv_conf << "\n";
    }

    // 添加DNS服务器（按优先级排序）
    std::vector<DNSServer> servers = getDNSServers();
    std::sort(servers.begin(), servers.end(),
        [](const DNSServer& a, const DNSServer& b) {
            return a.priority < b.priority;
        });

    for (const auto& server : servers) {
        resolv_conf << "nameserver " << server.ip_address << "\n";
    }

    std::cout << "[DNSManager] System DNS configuration:\n" << resolv_conf.str();
    
    // 实际实现中会写入 /etc/resolv.conf
    // std::ofstream file("/etc/resolv.conf");
    // file << resolv_conf.str();
    // file.close();

    return true;
}

bool DNSManager::addSearchDomain(const std::string& domain) {
    // 检查是否已存在
    for (const auto& d : search_domains_) {
        if (d == domain) {
            return false;
        }
    }
    search_domains_.push_back(domain);
    return true;
}

std::vector<std::string> DNSManager::getSearchDomains() const {
    return search_domains_;
}

void DNSManager::registerCallback(DNSCallback callback) {
    dns_callback_ = callback;
}

DNSManager::DNSStats DNSManager::getStats() const {
    return stats_;
}

DNSResolution DNSManager::performDNSQuery(const std::string& hostname, DNSQueryType query_type) {
    DNSResolution result;
    result.hostname = hostname;
    
    std::ostringstream cmd;
    cmd << "nslookup -type=" << getQueryTypeString(query_type) << " " << hostname;

    // 执行命令
    std::cout << "[DNSManager] Executing: " << cmd.str() << std::endl;

    // 模拟DNS解析结果
    if (query_type == DNSQueryType::A) {
        result.ip_addresses.push_back("93.184.216.34");
    } else if (query_type == DNSQueryType::AAAA) {
        result.ip_addresses.push_back("2606:2800:220:1:248:1893:25c8:1946");
    }

    result.success = !result.ip_addresses.empty();
    result.dns_server = dns_servers_.empty() ? "" : dns_servers_.begin()->second.ip_address;
    result.ttl = cache_ttl_;

    if (!result.success) {
        result.error_message = "Failed to resolve hostname: " + hostname;
    }

    return result;
}

DNSCacheEntry* DNSManager::findInCache(const std::string& hostname) {
    auto it = dns_cache_.find(hostname);
    if (it != dns_cache_.end()) {
        time_t now = time(nullptr);
        if (now - it->second.timestamp < it->second.ttl) {
            return &it->second;
        }
    }
    return nullptr;
}

void DNSManager::addToCache(const std::string& hostname, const DNSResolution& resolution) {
    DNSCacheEntry entry;
    entry.hostname = hostname;
    entry.resolution = resolution;
    entry.timestamp = time(nullptr);
    entry.ttl = cache_ttl_;
    
    dns_cache_[hostname] = entry;
    std::cout << "[DNSManager] Cached DNS resolution for: " << hostname << std::endl;
}

void DNSManager::cleanupExpiredCache() {
    time_t now = time(nullptr);
    auto it = dns_cache_.begin();
    
    while (it != dns_cache_.end()) {
        if (now - it->second.timestamp >= it->second.ttl) {
            std::cout << "[DNSManager] Removed expired cache entry: " << it->first << std::endl;
            it = dns_cache_.erase(it);
        } else {
            ++it;
        }
    }
}

bool DNSManager::executeCommand(const std::string& command) {
    // 模拟执行命令
    std::cout << "[DNSManager] Executing: " << command << std::endl;
    // 实际实现中会使用 system() 或 popen() 执行命令
    return true;
}

std::string DNSManager::getQueryTypeString(DNSQueryType type) {
    switch (type) {
        case DNSQueryType::A: return "A";
        case DNSQueryType::AAAA: return "AAAA";
        case DNSQueryType::MX: return "MX";
        case DNSQueryType::CNAME: return "CNAME";
        case DNSQueryType::TXT: return "TXT";
        case DNSQueryType::NS: return "NS";
        case DNSQueryType::PTR: return "PTR";
        case DNSQueryType::SRV: return "SRV";
        default: return "A";
    }
}